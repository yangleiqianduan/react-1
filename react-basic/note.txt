https://unpkg.com/babel-standalone@6.15.0/babel.js

https://github.com/facebook/react/releases

事件处理

语法：
React事件绑定属性的命名采用驼峰式写法，而不是小写。
如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串(DOM元素的写法)

JSX语法语法绑定事件
class Clock extends React.Component {
    constructor(props) {
        super(props);
    }

    domClick(event) {
    	console.log(this);
        console.log(event);
        event.preventDefault(); //组织默认行为
    }

    render() {
        return (
            <div onClick={this.domClick}>
                Test react event!
            </div>
        );
    }
}

ReactDOM.render(
    <Clock />,
    document.getElementById('root')
);

在 React 中另一个不同是你不能使用返回 false 的方式阻止默认行为。你必须明确的使用 preventDefault。

react 事件绑定函数带括号和不带括号的区别
上面我们理解到当前react的事件绑定是需要JSX语法。现在我将上面的代码修改一下，然后去进行我们的测试：

domClick(event) {
    console.log(this);
    console.log(event);
    event.preventDefault(); //阻止默认行为

    return "this is the result of fuction domClick";
}

render() {
    return (
        <div onClick={this.domClick}>
            Test react event!
        </div>
    );
}

然后我们去看一下当前当去创建elemnt的时候传进去的prop是什么？

这个时候我们可以看到当前穿进去的是一个函数，然后我们在将代码改成
domClick(event) {
    console.log(this);
    console.log(event);
    //event.preventDefault(); //阻止默认行为
}

render() {
    return (
        <div onClick={this.domClick()}>
            Test react event!
        </div>
    );
}

然后看一下当前的结果

从上面的结果可以看出当我们不加上括号的时候是正常的情况，因为此时dom绑定的是一个函数，但是加上括号，函数会先执行，然后将执行的结果进行dom绑定。正常会报错的，错误如下：

react-dom.development.js:526 Warning: Expected `onClick` listener to be a function, instead got a value of `string` type.
    in div (created by Clock)
    in Clock

但是呢，由于普通情况下用于绑定事件的函数都不会有返回值，所以不会报错，只是设置的事件绑定不会执行。这也是上面修改的code将注视了一行代码，因为没有event对象，因为当前就是函数执行表达式。


react this
从之前的内容我们了解到react的内部其实是有自己的生命周期函数，以及自己维护的状态，以及与其他组件交互的props。那么我们的this其实很重要，因为可能在我们的方法里是需要去更新当前组件的state，或者去执行父组件传进来的this.props内部的方法。所以我们需要确定我们的方法内部可以取得到当前组件this。

我们还是从上面的最普通的开始说起：
<div onClick={this.domClick}>
    Test react event!
</div>

当前情况下函数执行的时候this为undefined。为什么呢？因为当真正执行domClick的时候是浏览器引擎的callback函数，代码的执行由浏览器事件循环机制执行的。我之前有文章说过相关的内容。

bind()
详情访问：https://blog.csdn.net/it_rod/article/details/71036766#t8
Function.prototype.bind(thisArg, arg1, arg2, …) 是ES5新增的函数扩展方法，bind()返回一个新的函数对象，该函数的this被绑定到thisArg上，并向事件处理器中传入参数。

所以上面的代码改写如下：
render() {
    return (
        <div onClick={this.domClick.bind(this)}>
            Test react event!
        </div>
    );
}

构造函数内绑定
在构造函数 constructor 内绑定this，好处是仅需要绑定一次，避免每次渲染时都要重新绑定，函数在别处复用时也无需再次绑定。
这里的原因是因为在constructor函数中的内容都会执行一次。但是为什么可以这样做呢？

react内部在穿件组件的时候会执行一个方法constructClassInstance，内部是通过var instance = new ctor(props, context)创建组件。而且编译的时候构造函数的执行就是相当于new一个普通的function。至于new 一个普通的function的this是指向当前生成的对象的。详情可以访问：https://blog.csdn.net/it_rod/article/details/71036766#t8

class Clock extends React.Component {
    constructor(props) {
        super(props);
        this.domClick = this.domClick.bind(this)
    }

    domClick(event) {
        console.log(this);
        console.log(event);
        event.preventDefault(); //阻止默认行为

        //return "this is the result of fuction domClick";
    }

    render() {
        return (
            <div onClick={this.domClick}>
                Test react event!
            </div>
        );
    }
}

箭头函数
箭头函数则会捕获其所在上下文的this值，作为自己的this值，使用箭头函数就不用担心函数内的this不是指向组件内部了。详情访问：https://blog.csdn.net/it_rod/article/details/71036766#t10

这样的话使用就很方便了，只要是你在调用当前的这个函数的地方都可以使用箭头函数去表示。因为不管下面的几种方式使用哪一种，最后作用域的查找都会查找到组件层的this。除非自己方法内部去重新赋值this。
//第一种
render() {
    return (
        <div onClick={()=>{this.domClick}}>
            Test react event!
        </div>
    );
}


//第二种
domClick = (event) => {
    console.log(this);
    console.log(event);
    event.preventDefault(); //阻止默认行为

    //return "this is the result of fuction domClick";
}

render() {
    return (
        <div onClick={this.domClick}>
            Test react event!
        </div>
    );
}

当然你也可以在构造函数中去使用箭头函数，这里就不将例子写出来了。

向事件处理程序传递参数
